{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion: Analysis of Range Dependence on Launch Angle 1. Theoretical Foundation Projectile motion is governed by Newton\u2019s laws. Assuming no air resistance, the motion can be described using kinematic equations: Horizontal motion: \\[ x = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ y = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] The total time of flight is found by solving for when the projectile returns to its initial height: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The horizontal range is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range The horizontal range depends on: Launch Angle ( \\(\\theta\\) ) : The range is maximized at \\( 45^\\circ \\) . Initial Velocity ( \\(v_0\\) ) : Higher velocity increases range quadratically. Gravitational Acceleration (g): A stronger gravitational field decreases range. 3. Practical Applications Sports: Understanding ball trajectories in football and basketball. Engineering: Designing projectile-based systems like rockets or artillery. Astrophysics: Studying planetary motion under different gravity levels. Gymnastics: I did gymnastics for about 4.5 years, and even though I stopped, I still remember how much things like angle and push-off mattered during flips and vaults. Now that I\u2019m learning the physics behind it, it all makes a lot more sense. 4. Implementation: Python Simulation We use Python to visualize how range varies with launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees angles_rad = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity in m/s^2 projectile_range(v0, g) #### Range at Selected Launch Angles This graph shows how the horizontal range changes for selected launch angles (0\u00b0, 15\u00b0, ..., 90\u00b0). The range is maximized at 45\u00b0, and symmetric angles give equal ranges (like 30\u00b0 and 60\u00b0). Full Range vs. Launch Angle Plot This plot provides a smoother, continuous look at how launch angle affects range. It complements the previous graph by showing the full curve instead of selected angles. Range vs Initial Velocity at 45\u00b0 This graph shows how the range increases quadratically as the initial velocity increases, with a fixed launch angle of 45\u00b0. import numpy as np import matplotlib.pyplot as plt def range_vs_velocity(theta_deg, g): velocities = np.linspace(1, 50, 100) theta_rad = np.radians(theta_deg) ranges = (velocities**2 * np.sin(2 * theta_rad)) / g plt.figure(figsize=(8,5)) plt.plot(velocities, ranges) plt.xlabel('Initial Velocity (m/s)') plt.ylabel('Range (m)') plt.title(f'Range vs Initial Velocity at {theta_deg}\u00b0') plt.grid() plt.savefig(\"range_vs_velocity.png\", dpi=300) plt.show() range_vs_velocity(45, 9.81) Gymnastics-Style Jump (Simplified Example) import math # Gymnastics jump simulation v0 = 4 # initial velocity (m/s) angle = 50 # launch angle (degrees) g = 9.81 # gravity (m/s^2) theta = math.radians(angle) t = (2 * v0 * math.sin(theta)) / g R = (v0**2 * math.sin(2 * theta)) / g print(\"Time in air:\", round(t, 2), \"s\") print(\"Distance:\", round(R, 2), \"m\") # Calculate maximum height h_max = (v0**2 * math.sin(theta)**2) / (2 * g) print(\"Maximum height:\", round(h_max, 2), \"m\") This is a short example of how angle and velocity affect the flight time and distance of a jump, like in gymnastics. 5. Discussion on Limitations Air Resistance: In real scenarios, drag significantly reduces range. Uneven Terrain: Changes in landing elevation affect results. Wind Influence: Can alter trajectory unpredictably. 6. Examples Figure 1: Illustration showing how launch angle and velocity affect the range of projectile motion. Figure 2: Simulated projectile paths at 45\u00b0 launch angle with different initial velocities. Figure 3: Simulated projectile paths at 15,45,75\u00b0 launch angle with different initial velocities. Conclusion This analysis demonstrates the relationship between launch angle and range, emphasizing its significance in various real-world applications. It also helped me connect what I\u2019m learning now to the years I spent doing gymnastics. Future studies can include more realistic factors like air resistance and body posture during motion. visit my colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-of-range-dependence-on-launch-angle","text":"","title":"Projectile Motion: Analysis of Range Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by Newton\u2019s laws. Assuming no air resistance, the motion can be described using kinematic equations: Horizontal motion: \\[ x = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ y = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] The total time of flight is found by solving for when the projectile returns to its initial height: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The horizontal range is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range depends on: Launch Angle ( \\(\\theta\\) ) : The range is maximized at \\( 45^\\circ \\) . Initial Velocity ( \\(v_0\\) ) : Higher velocity increases range quadratically. Gravitational Acceleration (g): A stronger gravitational field decreases range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding ball trajectories in football and basketball. Engineering: Designing projectile-based systems like rockets or artillery. Astrophysics: Studying planetary motion under different gravity levels. Gymnastics: I did gymnastics for about 4.5 years, and even though I stopped, I still remember how much things like angle and push-off mattered during flips and vaults. Now that I\u2019m learning the physics behind it, it all makes a lot more sense.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"We use Python to visualize how range varies with launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees angles_rad = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity in m/s^2 projectile_range(v0, g) #### Range at Selected Launch Angles This graph shows how the horizontal range changes for selected launch angles (0\u00b0, 15\u00b0, ..., 90\u00b0). The range is maximized at 45\u00b0, and symmetric angles give equal ranges (like 30\u00b0 and 60\u00b0).","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#full-range-vs-launch-angle-plot","text":"This plot provides a smoother, continuous look at how launch angle affects range. It complements the previous graph by showing the full curve instead of selected angles.","title":"Full Range vs. Launch Angle Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-initial-velocity-at-45","text":"This graph shows how the range increases quadratically as the initial velocity increases, with a fixed launch angle of 45\u00b0. import numpy as np import matplotlib.pyplot as plt def range_vs_velocity(theta_deg, g): velocities = np.linspace(1, 50, 100) theta_rad = np.radians(theta_deg) ranges = (velocities**2 * np.sin(2 * theta_rad)) / g plt.figure(figsize=(8,5)) plt.plot(velocities, ranges) plt.xlabel('Initial Velocity (m/s)') plt.ylabel('Range (m)') plt.title(f'Range vs Initial Velocity at {theta_deg}\u00b0') plt.grid() plt.savefig(\"range_vs_velocity.png\", dpi=300) plt.show() range_vs_velocity(45, 9.81)","title":"Range vs Initial Velocity at 45\u00b0"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#gymnastics-style-jump-simplified-example","text":"import math # Gymnastics jump simulation v0 = 4 # initial velocity (m/s) angle = 50 # launch angle (degrees) g = 9.81 # gravity (m/s^2) theta = math.radians(angle) t = (2 * v0 * math.sin(theta)) / g R = (v0**2 * math.sin(2 * theta)) / g print(\"Time in air:\", round(t, 2), \"s\") print(\"Distance:\", round(R, 2), \"m\") # Calculate maximum height h_max = (v0**2 * math.sin(theta)**2) / (2 * g) print(\"Maximum height:\", round(h_max, 2), \"m\") This is a short example of how angle and velocity affect the flight time and distance of a jump, like in gymnastics.","title":"Gymnastics-Style Jump (Simplified Example)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion-on-limitations","text":"Air Resistance: In real scenarios, drag significantly reduces range. Uneven Terrain: Changes in landing elevation affect results. Wind Influence: Can alter trajectory unpredictably.","title":"5. Discussion on Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-examples","text":"Figure 1: Illustration showing how launch angle and velocity affect the range of projectile motion. Figure 2: Simulated projectile paths at 45\u00b0 launch angle with different initial velocities. Figure 3: Simulated projectile paths at 15,45,75\u00b0 launch angle with different initial velocities.","title":"6. Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis demonstrates the relationship between launch angle and range, emphasizing its significance in various real-world applications. It also helped me connect what I\u2019m learning now to the years I spent doing gymnastics. Future studies can include more realistic factors like air resistance and body posture during motion. visit my colab","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping , restoring forces , and external driving forces . By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including: Resonance Chaos Quasiperiodic behavior These phenomena form the foundation for understanding complex real-world systems such as: - Driven oscillators - Climate systems - Mechanical structures under periodic stress The introduction of forcing adds new parameters, like amplitude and frequency of the external force, significantly affecting the system's behavior. Varying these parameters leads to diverse behaviors: - Synchronized oscillations - Resonance - Chaotic motion These principles are widely used in engineering applications such as: - Energy harvesting - Vibration isolation - Mechanical resonance analysis Task 1. Theoretical Foundation The equation governing the motion of a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Small-Angle Approximation For small angular displacements ( \\( \\theta \\ll 1 \\) ), we approximate: \\[ \\sin(\\theta) \\approx \\theta \\] Thus, the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear second-order ODE. Its general solution consists of: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] \\( \\theta_{\\text{hom}}(t) \\) : homogeneous (damped) solution \\( \\theta_{\\text{part}}(t) \\) : particular (forced) solution Resonance If the driving frequency \\( \\omega \\) approaches the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , the system exhibits resonance , where oscillation amplitude grows significantly, especially for low damping \\( b \\) . This is critical in engineering design to avoid destructive oscillations. 2. Analysis of Dynamics Investigate how varying: - Damping coefficient \\( b \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\) affects the pendulum's motion. Focus on transitions between: Periodic motion Quasiperiodic motion Chaotic motion Insight : - Increasing \\( A \\) or decreasing \\( b \\) may push the system from periodic to chaotic behavior. - Stronger damping reduces amplitude and prevents instability. 3. Practical Applications The forced damped pendulum model applies to several real-world systems, including: - Energy harvesting devices (e.g., vibrations in vehicles or bridges) - Suspension bridges under periodic wind loads - Driven RLC circuits in electrical systems - Biomechanical systems , such as human gait analysis 4. Implementation We simulate the pendulum using Python and visualize the results through various plots. Example Python Implementation Comparison of Three Pendulum Scenarios The figure below presents three different cases of pendulum motion: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping only) Forced Pendulum (damping + external force) Each row shows: - Left: Time series of the angle (\u03b8 vs time) - Right: Corresponding phase diagram (\u03b8 vs \u03c9) This comparison helps visualize how damping and external forcing impact the system's dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravitational acceleration (m/s^2) L = 1.0 # Length of pendulum (m) A = 1.2 # Driving force amplitude w = 2.0 # Driving frequency (rad/s) # ODE System def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Time domain and initial conditions t = np.linspace(0, 50, 1000) y0 = [0.1, 0.0] # Initial angle and angular velocity # Numerical solution sol = solve_ivp(pendulum, [t[0], t[-1]], y0, t_eval=t) # Angle vs Time plt.figure() plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() This graph shows how the angle of the forced damped pendulum evolves over time. Angle vs Time \u2013 Resonance Behavior This plot shows large and regular oscillations due to resonance. The system absorbs energy efficiently from the external force, resulting in high-amplitude, periodic motion. It represents a typical resonant response with minimal damping and driving frequency close to natural frequency. Angular Velocity vs Time The following graph illustrates how the angular velocity of the forced damped pendulum changes over time. This visualization helps understand how damping and external driving forces affect the rotational speed (\u03c9) of the pendulum. Kinetic vs Potential Energy This plot compares the kinetic and potential energy of the pendulum. Total Energy Loss Over Time (Log Scale) This log-scaled graph shows how the total mechanical energy of the system decreases over time due to damping. Parametric Curve: \u03b8 vs \u03c9 This graph visualizes the relationship between angular displacement (\u03b8) and angular velocity (\u03c9) over time, forming a parametric curve. # Phase Diagram: \u03b8 vs \u03c9 plt.figure() plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Diagram: \u03b8 vs \u03c9\") plt.xlabel(\"Angle (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show() This phase diagram shows the relationship between angular displacement and angular velocity, helping us understand the system\u2019s dynamics (e.g. chaotic behavior). Phase Diagram \u2013 Chaotic Behavior This phase diagram illustrates the system's behavior under chaotic conditions. In this scenario, the damping coefficient ( b = 0.5 ) and driving amplitude ( A = 1.2 ) are set to values that push the pendulum into a nonlinear, unpredictable regime. The diagram shows a dense and non-repeating pattern, which is a hallmark of chaos. Such behavior is highly sensitive to initial conditions and does not settle into a stable orbit. Phase Diagram \u2013 Resonance Behavior This phase diagram shows the response of the system near its natural frequency, producing resonance. With low damping ( b = 0.1 ) and a driving frequency approximately equal to the system\u2019s natural frequency ( \u03c9 \u2248 \u221a(g/L) ), the pendulum absorbs energy efficiently. This results in large, smooth, and repeating loops in phase space \u2013 a characteristic of resonant oscillations. The motion is regular and periodic, unlike the chaotic case. # Total Mechanical Energy theta, omega = sol.y kinetic = 0.5 * (L**2) * omega**2 potential = g * L * (1 - np.cos(theta)) total_energy = kinetic + potential plt.figure() plt.plot(sol.t, total_energy) plt.title(\"Total Mechanical Energy vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Energy (Joules)\") plt.grid(True) plt.show() This graph displays the total mechanical energy (kinetic + potential) of the system over time. Poincar\u00e9 Section (sampled at driving period intervals) T = 2 * np.pi / w poincare_theta = [] poincare_omega = [] for i in range(len(sol.t)): if np.isclose(sol.t[i] % T, 0, atol=0.05): poincare_theta.append(sol.y[0][i]) poincare_omega.append(sol.y[1][i]) plt.figure() plt.scatter(poincare_theta, poincare_omega, s=10, color='darkred') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"\u03c9 (rad/s)\") plt.grid(True) plt.show() This graph visualizes the system's state at specific time intervals, helping identify whether the system is chaotic or periodic. Deliverables A Markdown document or Jupyter notebook implementing the simulation. A theoretical explanation including the small-angle approximation and resonance effects. Plots illustrating: Time evolution of angle Phase diagrams Energy over time Poincar\u00e9 sections A discussion on: Transition from periodic to chaotic motion Effects of damping and forcing parameters Optional extensions: Bifurcation diagrams Nonlinear damping Stochastic or aperiodic driving forces Hints and Resources Use the small-angle approximation: \\[ \\sin(\\theta) \\approx \\theta \\quad \\text{(for small angles)} \\] Apply numerical integration techniques (e.g., Runge-Kutta 4 or solve_ivp ) to solve the ODE. Recommended libraries: numpy for numerical operations scipy.integrate for solving differential equations matplotlib for visualization Analogous systems for further exploration: Driven RLC circuits in electrical engineering Biomechanical modeling of periodic limb motion visit my colab","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2: Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping , restoring forces , and external driving forces . By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including: Resonance Chaos Quasiperiodic behavior These phenomena form the foundation for understanding complex real-world systems such as: - Driven oscillators - Climate systems - Mechanical structures under periodic stress The introduction of forcing adds new parameters, like amplitude and frequency of the external force, significantly affecting the system's behavior. Varying these parameters leads to diverse behaviors: - Synchronized oscillations - Resonance - Chaotic motion These principles are widely used in engineering applications such as: - Energy harvesting - Vibration isolation - Mechanical resonance analysis","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation governing the motion of a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angular displacements ( \\( \\theta \\ll 1 \\) ), we approximate: \\[ \\sin(\\theta) \\approx \\theta \\] Thus, the equation becomes: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear second-order ODE. Its general solution consists of: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] \\( \\theta_{\\text{hom}}(t) \\) : homogeneous (damped) solution \\( \\theta_{\\text{part}}(t) \\) : particular (forced) solution","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"If the driving frequency \\( \\omega \\) approaches the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , the system exhibits resonance , where oscillation amplitude grows significantly, especially for low damping \\( b \\) . This is critical in engineering design to avoid destructive oscillations.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Investigate how varying: - Damping coefficient \\( b \\) - Driving amplitude \\( A \\) - Driving frequency \\( \\omega \\) affects the pendulum's motion. Focus on transitions between: Periodic motion Quasiperiodic motion Chaotic motion Insight : - Increasing \\( A \\) or decreasing \\( b \\) may push the system from periodic to chaotic behavior. - Stronger damping reduces amplitude and prevents instability.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to several real-world systems, including: - Energy harvesting devices (e.g., vibrations in vehicles or bridges) - Suspension bridges under periodic wind loads - Driven RLC circuits in electrical systems - Biomechanical systems , such as human gait analysis","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We simulate the pendulum using Python and visualize the results through various plots.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-python-implementation","text":"","title":"Example Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#comparison-of-three-pendulum-scenarios","text":"The figure below presents three different cases of pendulum motion: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping only) Forced Pendulum (damping + external force) Each row shows: - Left: Time series of the angle (\u03b8 vs time) - Right: Corresponding phase diagram (\u03b8 vs \u03c9) This comparison helps visualize how damping and external forcing impact the system's dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravitational acceleration (m/s^2) L = 1.0 # Length of pendulum (m) A = 1.2 # Driving force amplitude w = 2.0 # Driving frequency (rad/s) # ODE System def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Time domain and initial conditions t = np.linspace(0, 50, 1000) y0 = [0.1, 0.0] # Initial angle and angular velocity # Numerical solution sol = solve_ivp(pendulum, [t[0], t[-1]], y0, t_eval=t) # Angle vs Time plt.figure() plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show() This graph shows how the angle of the forced damped pendulum evolves over time.","title":"Comparison of Three Pendulum Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#angle-vs-time-resonance-behavior","text":"This plot shows large and regular oscillations due to resonance. The system absorbs energy efficiently from the external force, resulting in high-amplitude, periodic motion. It represents a typical resonant response with minimal damping and driving frequency close to natural frequency.","title":"Angle vs Time \u2013 Resonance Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#angular-velocity-vs-time","text":"The following graph illustrates how the angular velocity of the forced damped pendulum changes over time. This visualization helps understand how damping and external driving forces affect the rotational speed (\u03c9) of the pendulum.","title":"Angular Velocity vs Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#kinetic-vs-potential-energy","text":"This plot compares the kinetic and potential energy of the pendulum.","title":"Kinetic vs Potential Energy"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#total-energy-loss-over-time-log-scale","text":"This log-scaled graph shows how the total mechanical energy of the system decreases over time due to damping.","title":"Total Energy Loss Over Time (Log Scale)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parametric-curve-vs","text":"This graph visualizes the relationship between angular displacement (\u03b8) and angular velocity (\u03c9) over time, forming a parametric curve. # Phase Diagram: \u03b8 vs \u03c9 plt.figure() plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Diagram: \u03b8 vs \u03c9\") plt.xlabel(\"Angle (rad)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.grid(True) plt.show() This phase diagram shows the relationship between angular displacement and angular velocity, helping us understand the system\u2019s dynamics (e.g. chaotic behavior).","title":"Parametric Curve: \u03b8 vs \u03c9"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagram-chaotic-behavior","text":"This phase diagram illustrates the system's behavior under chaotic conditions. In this scenario, the damping coefficient ( b = 0.5 ) and driving amplitude ( A = 1.2 ) are set to values that push the pendulum into a nonlinear, unpredictable regime. The diagram shows a dense and non-repeating pattern, which is a hallmark of chaos. Such behavior is highly sensitive to initial conditions and does not settle into a stable orbit.","title":"Phase Diagram \u2013 Chaotic Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagram-resonance-behavior","text":"This phase diagram shows the response of the system near its natural frequency, producing resonance. With low damping ( b = 0.1 ) and a driving frequency approximately equal to the system\u2019s natural frequency ( \u03c9 \u2248 \u221a(g/L) ), the pendulum absorbs energy efficiently. This results in large, smooth, and repeating loops in phase space \u2013 a characteristic of resonant oscillations. The motion is regular and periodic, unlike the chaotic case. # Total Mechanical Energy theta, omega = sol.y kinetic = 0.5 * (L**2) * omega**2 potential = g * L * (1 - np.cos(theta)) total_energy = kinetic + potential plt.figure() plt.plot(sol.t, total_energy) plt.title(\"Total Mechanical Energy vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Energy (Joules)\") plt.grid(True) plt.show() This graph displays the total mechanical energy (kinetic + potential) of the system over time.","title":"Phase Diagram \u2013 Resonance Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section-sampled-at-driving-period-intervals","text":"T = 2 * np.pi / w poincare_theta = [] poincare_omega = [] for i in range(len(sol.t)): if np.isclose(sol.t[i] % T, 0, atol=0.05): poincare_theta.append(sol.y[0][i]) poincare_omega.append(sol.y[1][i]) plt.figure() plt.scatter(poincare_theta, poincare_omega, s=10, color='darkred') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"\u03c9 (rad/s)\") plt.grid(True) plt.show() This graph visualizes the system's state at specific time intervals, helping identify whether the system is chaotic or periodic.","title":"Poincar\u00e9 Section (sampled at driving period intervals)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"A Markdown document or Jupyter notebook implementing the simulation. A theoretical explanation including the small-angle approximation and resonance effects. Plots illustrating: Time evolution of angle Phase diagrams Energy over time Poincar\u00e9 sections A discussion on: Transition from periodic to chaotic motion Effects of damping and forcing parameters Optional extensions: Bifurcation diagrams Nonlinear damping Stochastic or aperiodic driving forces","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"Use the small-angle approximation: \\[ \\sin(\\theta) \\approx \\theta \\quad \\text{(for small angles)} \\] Apply numerical integration techniques (e.g., Runge-Kutta 4 or solve_ivp ) to solve the ODE. Recommended libraries: numpy for numerical operations scipy.integrate for solving differential equations matplotlib for visualization Analogous systems for further exploration: Driven RLC circuits in electrical engineering Biomechanical modeling of periodic limb motion visit my colab","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation \"Kepler's Third Law\" links the square of the orbital period with the cube of the orbital radius, forming a cornerstone of celestial mechanics. Purpose: Understand planetary motions and gravitational interactions from satellites to cosmic scales. Goal: Connect fundamental principles of gravity to real-world phenomena like satellite orbits and planetary systems. Derivation of Kepler\u2019s Third Law Starting from Newton's Law of Universal Gravitation: \\[ F_{gravity} = \\frac{GMm}{r^2} \\] and the centripetal force required for circular motion: \\[ F_{centripetal} = \\frac{mv^2}{r} \\] Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying: \\[ v^2 = \\frac{GM}{r} \\] The orbital period \\(T\\) is related to \\(v\\) as: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{GM}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r} \\] Cross-multiplying: \\[ 4\\pi^2 r^3 = GMT^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] For elliptical orbits, replace \\(r\\) with \\(a\\) (semi-major axis): \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] Application: Mass Calculation using Kepler\u2019s Law We can use the derived equation to calculate the mass of a central body (such as the Earth or the Sun): \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\] 1. Mass of the Earth (using a satellite or the Moon) Given: - Orbital radius: \\(r = 3.84 \\times 10^8\\) m - Orbital period: \\(T = 2.36 \\times 10^6\\) s - Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 \\[ M_{\\text{Earth}} = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] 2. Mass of the Sun (using Earth\u2019s orbit) Given: - Orbital radius: \\(r = 1.496 \\times 10^{11}\\) m - Orbital period: \\(T = 3.154 \\times 10^7\\) s \\[ M_{\\odot} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} \\cdot (3.154 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\text{ kg} \\] These calculations show that Kepler\u2019s Third Law allows us to estimate the mass of large celestial bodies using only orbital data. Task List Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Analyze real-world examples, such as the Moon\u2019s orbit around Earth or the orbits of planets in the Solar System. Implement a computational model to simulate circular orbits and verify the relationship. Deliverables A Markdown document containing explanations and Python code. A detailed explanation of orbital mechanics and Kepler\u2019s Third Law. Graphical representations generated from simulations and real data. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Got it! I'll show all the computations step-by-step clearly, using double dollars ($$) for the formulas \u2014 very short but complete. \ud83c\udf0d\u2600\ufe0f Short Note: Mass Derivation with Full Computations Kepler-Newton Law: \\[ \\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M} \\] thus \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] \ud83c\udf0d 1. Earth's Mass (using Moon orbit) Given: \\(r=3.84\\times10^8\\,\\text{m}\\) \\(T=27.32\\,\\text{days}=27.32\\times86400=2.36\\times10^6\\,\\text{s}\\) \\(G=6.67430\\times10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}\\) Substituting: \\[ M_{\\text{Earth}} = \\frac{4\\pi^2(3.84\\times10^8)^3}{(6.67430\\times10^{-11})(2.36\\times10^6)^2} \\] First compute: \\((3.84\\times10^8)^3=5.67\\times10^{25}\\) \\((2.36\\times10^6)^2=5.57\\times10^{12}\\) Thus: \\[ M_{\\text{Earth}} = \\frac{4\\pi^2(5.67\\times10^{25})}{(6.67430\\times10^{-11})(5.57\\times10^{12})} \\] Finally: \\[ M_{\\text{Earth}}\\approx5.97\\times10^{24}\\,\\text{kg} \\] \u2600\ufe0f 2. Sun's Mass (using Earth orbit) Given: \\(r=1.496\\times10^{11}\\,\\text{m}\\) \\(T=1\\,\\text{year}=3.156\\times10^7\\,\\text{s}\\) \\(G=6.67430\\times10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}\\) Substituting: \\[ M_{\\text{Sun}} = \\frac{4\\pi^2(1.496\\times10^{11})^3}{(6.67430\\times10^{-11})(3.156\\times10^7)^2} \\] First compute: \\((1.496\\times10^{11})^3=3.35\\times10^{33}\\) \\((3.156\\times10^7)^2=9.96\\times10^{14}\\) Thus: \\[ M_{\\text{Sun}} = \\frac{4\\pi^2(3.35\\times10^{33})}{(6.67430\\times10^{-11})(9.96\\times10^{14})} \\] Finally: \\[ M_{\\text{Sun}}\\approx1.99\\times10^{30}\\,\\text{kg} \\] Graphs Section Graph 1: Total Orbital Energy vs Orbital Radius import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg m = 5.972e24 # Mass of Earth (kg) -- \u00f6rnek i\u00e7in radii = np.linspace(5e10, 1e12, 100) energies = - (G * M * m) / (2 * radii) plt.figure(figsize=(8,6)) plt.plot(radii, energies, 'o') plt.xlabel('Orbital Radius (r) [m]') plt.ylabel('Total Orbital Energy (E) [J]') plt.title('Total Orbital Energy vs Orbital Radius') plt.grid(True) plt.tight_layout() plt.savefig('total_orbital_energy_vs_radius.png') plt.show() Planetary Orbital Data Table Planet Orbital Radius (r) [m] Orbital Period (T) [s] Mercury 5.79 \u00d7 10\u00b9\u2070 7.6 \u00d7 10\u2076 Venus 1.082 \u00d7 10\u00b9\u00b9 1.94 \u00d7 10\u2077 Earth 1.496 \u00d7 10\u00b9\u00b9 3.15 \u00d7 10\u2077 Mars 2.279 \u00d7 10\u00b9\u00b9 5.94 \u00d7 10\u2077 Graph 2: T\u00b2 vs r\u00b3 with Planet Names import numpy as np import matplotlib.pyplot as plt # Planetary data radii = np.array([5.79e10, 1.082e11, 1.496e11, 2.279e11]) # [m] periods = np.array([7.6e6, 1.94e7, 3.15e7, 5.94e7]) # [s] planets = ['Mercury', 'Venus', 'Earth', 'Mars'] # Calculate r\u00b3 and T\u00b2 r_cubed = radii**3 T_squared = periods**2 # Perform linear fit (least squares): T\u00b2 = k * r\u00b3 coeffs = np.polyfit(r_cubed, T_squared, 1) k = coeffs[0] # Create a perfect line between min and max r\u00b3 r_fit = np.linspace(r_cubed.min()*0.9, r_cubed.max()*1.1, 500) # daha geni\u015f ve s\u0131k \u00e7izim i\u00e7in 500 nokta T_fit = k * r_fit # Plot the data points plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label='Planets', s=60) # scatter daha \u015f\u0131k olur plt.plot(r_fit, T_fit, 'r-', label=\"Kepler's Law (T\u00b2 \u221d r\u00b3)\", linewidth=2) # d\u00fczg\u00fcn k\u0131rm\u0131z\u0131 \u00e7izgi # Annotate each planet for i in range(len(planets)): plt.annotate(planets[i], (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(10, 10), ha='center') # Labels and title plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('T\u00b2 vs r\u00b3: Real Planets (Smooth Fit)') plt.grid(True) plt.legend() plt.tight_layout() plt.savefig('planets_kepler_law_smooth.png') plt.show() Conclusion In this project, we derived Kepler's Third Law starting from Newton's principles and verified it using simulated and real-world planetary data. Various graphical analyses confirmed the proportional relationship between the square of the orbital period and the cube of the orbital radius. This study enhances our understanding of orbital mechanics, an essential aspect of celestial physics. visit my colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"\"Kepler's Third Law\" links the square of the orbital period with the cube of the orbital radius, forming a cornerstone of celestial mechanics. Purpose: Understand planetary motions and gravitational interactions from satellites to cosmic scales. Goal: Connect fundamental principles of gravity to real-world phenomena like satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Starting from Newton's Law of Universal Gravitation: \\[ F_{gravity} = \\frac{GMm}{r^2} \\] and the centripetal force required for circular motion: \\[ F_{centripetal} = \\frac{mv^2}{r} \\] Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying: \\[ v^2 = \\frac{GM}{r} \\] The orbital period \\(T\\) is related to \\(v\\) as: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{GM}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r} \\] Cross-multiplying: \\[ 4\\pi^2 r^3 = GMT^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] For elliptical orbits, replace \\(r\\) with \\(a\\) (semi-major axis): \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\]","title":"Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#application-mass-calculation-using-keplers-law","text":"We can use the derived equation to calculate the mass of a central body (such as the Earth or the Sun): \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\quad \\Rightarrow \\quad M = \\frac{4\\pi^2 r^3}{G T^2} \\]","title":"Application: Mass Calculation using Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-mass-of-the-earth-using-a-satellite-or-the-moon","text":"Given: - Orbital radius: \\(r = 3.84 \\times 10^8\\) m - Orbital period: \\(T = 2.36 \\times 10^6\\) s - Gravitational constant: \\(G = 6.674 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 \\[ M_{\\text{Earth}} = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} \\cdot (2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\]","title":"1. Mass of the Earth (using a satellite or the Moon)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-mass-of-the-sun-using-earths-orbit","text":"Given: - Orbital radius: \\(r = 1.496 \\times 10^{11}\\) m - Orbital period: \\(T = 3.154 \\times 10^7\\) s \\[ M_{\\odot} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{6.674 \\times 10^{-11} \\cdot (3.154 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\text{ kg} \\] These calculations show that Kepler\u2019s Third Law allows us to estimate the mass of large celestial bodies using only orbital data.","title":"2. Mass of the Sun (using Earth\u2019s orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-list","text":"Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Analyze real-world examples, such as the Moon\u2019s orbit around Earth or the orbits of planets in the Solar System. Implement a computational model to simulate circular orbits and verify the relationship.","title":"Task List"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"A Markdown document containing explanations and Python code. A detailed explanation of orbital mechanics and Kepler\u2019s Third Law. Graphical representations generated from simulations and real data. A discussion on how this relationship extends to elliptical orbits and other celestial bodies. Got it! I'll show all the computations step-by-step clearly, using double dollars ($$) for the formulas \u2014 very short but complete.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#short-note-mass-derivation-with-full-computations","text":"Kepler-Newton Law: \\[ \\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M} \\] thus \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\]","title":"\ud83c\udf0d\u2600\ufe0f Short Note: Mass Derivation with Full Computations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-earths-mass-using-moon-orbit","text":"Given: \\(r=3.84\\times10^8\\,\\text{m}\\) \\(T=27.32\\,\\text{days}=27.32\\times86400=2.36\\times10^6\\,\\text{s}\\) \\(G=6.67430\\times10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}\\) Substituting: \\[ M_{\\text{Earth}} = \\frac{4\\pi^2(3.84\\times10^8)^3}{(6.67430\\times10^{-11})(2.36\\times10^6)^2} \\] First compute: \\((3.84\\times10^8)^3=5.67\\times10^{25}\\) \\((2.36\\times10^6)^2=5.57\\times10^{12}\\) Thus: \\[ M_{\\text{Earth}} = \\frac{4\\pi^2(5.67\\times10^{25})}{(6.67430\\times10^{-11})(5.57\\times10^{12})} \\] Finally: \\[ M_{\\text{Earth}}\\approx5.97\\times10^{24}\\,\\text{kg} \\]","title":"\ud83c\udf0d 1. Earth's Mass (using Moon orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-suns-mass-using-earth-orbit","text":"Given: \\(r=1.496\\times10^{11}\\,\\text{m}\\) \\(T=1\\,\\text{year}=3.156\\times10^7\\,\\text{s}\\) \\(G=6.67430\\times10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}\\) Substituting: \\[ M_{\\text{Sun}} = \\frac{4\\pi^2(1.496\\times10^{11})^3}{(6.67430\\times10^{-11})(3.156\\times10^7)^2} \\] First compute: \\((1.496\\times10^{11})^3=3.35\\times10^{33}\\) \\((3.156\\times10^7)^2=9.96\\times10^{14}\\) Thus: \\[ M_{\\text{Sun}} = \\frac{4\\pi^2(3.35\\times10^{33})}{(6.67430\\times10^{-11})(9.96\\times10^{14})} \\] Finally: \\[ M_{\\text{Sun}}\\approx1.99\\times10^{30}\\,\\text{kg} \\]","title":"\u2600\ufe0f 2. Sun's Mass (using Earth orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphs-section","text":"","title":"Graphs Section"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-1-total-orbital-energy-vs-orbital-radius","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg m = 5.972e24 # Mass of Earth (kg) -- \u00f6rnek i\u00e7in radii = np.linspace(5e10, 1e12, 100) energies = - (G * M * m) / (2 * radii) plt.figure(figsize=(8,6)) plt.plot(radii, energies, 'o') plt.xlabel('Orbital Radius (r) [m]') plt.ylabel('Total Orbital Energy (E) [J]') plt.title('Total Orbital Energy vs Orbital Radius') plt.grid(True) plt.tight_layout() plt.savefig('total_orbital_energy_vs_radius.png') plt.show()","title":"Graph 1: Total Orbital Energy vs Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbital-data-table","text":"Planet Orbital Radius (r) [m] Orbital Period (T) [s] Mercury 5.79 \u00d7 10\u00b9\u2070 7.6 \u00d7 10\u2076 Venus 1.082 \u00d7 10\u00b9\u00b9 1.94 \u00d7 10\u2077 Earth 1.496 \u00d7 10\u00b9\u00b9 3.15 \u00d7 10\u2077 Mars 2.279 \u00d7 10\u00b9\u00b9 5.94 \u00d7 10\u2077","title":"Planetary Orbital Data Table"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-2-t2-vs-r3-with-planet-names","text":"import numpy as np import matplotlib.pyplot as plt # Planetary data radii = np.array([5.79e10, 1.082e11, 1.496e11, 2.279e11]) # [m] periods = np.array([7.6e6, 1.94e7, 3.15e7, 5.94e7]) # [s] planets = ['Mercury', 'Venus', 'Earth', 'Mars'] # Calculate r\u00b3 and T\u00b2 r_cubed = radii**3 T_squared = periods**2 # Perform linear fit (least squares): T\u00b2 = k * r\u00b3 coeffs = np.polyfit(r_cubed, T_squared, 1) k = coeffs[0] # Create a perfect line between min and max r\u00b3 r_fit = np.linspace(r_cubed.min()*0.9, r_cubed.max()*1.1, 500) # daha geni\u015f ve s\u0131k \u00e7izim i\u00e7in 500 nokta T_fit = k * r_fit # Plot the data points plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label='Planets', s=60) # scatter daha \u015f\u0131k olur plt.plot(r_fit, T_fit, 'r-', label=\"Kepler's Law (T\u00b2 \u221d r\u00b3)\", linewidth=2) # d\u00fczg\u00fcn k\u0131rm\u0131z\u0131 \u00e7izgi # Annotate each planet for i in range(len(planets)): plt.annotate(planets[i], (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(10, 10), ha='center') # Labels and title plt.xlabel('Orbital Radius Cubed (r\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('T\u00b2 vs r\u00b3: Real Planets (Smooth Fit)') plt.grid(True) plt.legend() plt.tight_layout() plt.savefig('planets_kepler_law_smooth.png') plt.show()","title":"Graph 2: T\u00b2 vs r\u00b3 with Planet Names"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"In this project, we derived Kepler's Third Law starting from Newton's principles and verified it using simulated and real-world planetary data. Various graphical analyses confirmed the proportional relationship between the square of the orbital period and the cube of the orbital radius. This study enhances our understanding of orbital mechanics, an essential aspect of celestial physics. visit my colab","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 \ud83d\ude80 Cosmic Velocities: Derivations, Calculations & Comparisons 1\ufe0f\u20e3 First Cosmic Velocity \u2014 Orbital Velocity To stay in a circular orbit, the gravitational force must equal centripetal force: v\u2081 = \u221a(GM / r) Where: - G : Universal gravitational constant - M : Mass of the planet - r : Distance from the planet's center (or surface radius) 2\ufe0f\u20e3 Second Cosmic Velocity \u2014 Escape Velocity To escape a planet's gravity, an object must have enough kinetic energy to equal the gravitational potential energy: v\u2082 = \u221a(2GM / r) = \u221a2 \u00d7 v\u2081 3\ufe0f\u20e3 Third Cosmic Velocity \u2014 Leaving the Star System To leave the solar system, an object must escape not only the planet\u2019s gravity, but also the Sun\u2019s gravity from the planet\u2019s orbital position: v\u2083 = \u221a(v_sun_escape\u00b2 + v_orbit\u00b2) Where: - v_sun_escape = \u221a(2GM_sun / r_orbit) - v_orbit = orbital speed of the planet around the Sun \ud83c\udf0d Earth: Numerical Values Using Earth mass and radius: \\( M = 5.972 \\times 10^{24} \\) kg \\( r = 6.371 \\times 10^6 \\) m \\( G = 6.67430 \\times 10^{-11} \\) We find: First velocity (orbit) : ~7900 m/s Second velocity (escape) : ~11200 m/s Third velocity (leave solar system) : ~42100 m/s \ud83d\udcca Comparison Table: Earth vs Moon, Mars, Jupiter Body v\u2081 (orbit) v\u2082 (escape) v\u2083 (solar escape) Earth ~7900 m/s ~11200 m/s ~42100 m/s Moon ~1700 m/s ~2400 m/s ~41000 m/s Mars ~3500 m/s ~5000 m/s ~36500 m/s Jupiter ~42000 m/s ~59500 m/s ~61700 m/s \ud83e\udde0 Python Code to Generate Visualizations (For Colab) import numpy as np import matplotlib.pyplot as plt from IPython.display import Image, display # Gravitational constant G = 6.67430e-11 # Celestial body data: [mass (kg), radius (m), orbital speed around Sun (m/s)] bodies = { \"Earth\": [5.972e24, 6.371e6, 29.78e3], \"Moon\": [7.347e22, 1.737e6, 1.022e3], \"Mars\": [6.417e23, 3.3895e6, 24.077e3], \"Jupiter\": [1.898e27, 6.9911e7, 13.07e3] } M_sun = 1.989e30 AU = 1.496e11 # Calculate cosmic velocities results = {} for name, (mass, radius, v_orb) in bodies.items(): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_sun_escape = np.sqrt(2 * G * M_sun / AU) v3 = np.sqrt(v_sun_escape**2 + v_orb**2) results[name] = [v1, v2, v3] labels = [\"v\u2081 (Orbit)\", \"v\u2082 (Escape)\", \"v\u2083 (Solar Escape)\"] # Individual bar charts per planet for name, velocities in results.items(): plt.figure() plt.bar(labels, velocities) plt.title(f\"{name} - Cosmic Velocities\") plt.ylabel(\"Velocity (m/s)\") plt.grid(True) plt.tight_layout() filename = f\"{name.lower()}_velocities.png\" plt.savefig(filename) display(Image(filename)) plt.close() # Comparison chart: velocity types across planets v1_vals, v2_vals, v3_vals = [], [], [] planet_names = list(results.keys()) for name in planet_names: v1_vals.append(results[name][0]) v2_vals.append(results[name][1]) v3_vals.append(results[name][2]) x = np.arange(len(planet_names)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_vals, width, label=\"v\u2081 (Orbit)\") ax.bar(x, v2_vals, width, label=\"v\u2082 (Escape)\") ax.bar(x + width, v3_vals, width, label=\"v\u2083 (Solar Escape)\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Comparison of Cosmic Velocities Across Celestial Bodies\") ax.set_xticks(x) ax.set_xticklabels(planet_names) ax.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"velocity_comparison_by_type.png\") display(Image(\"velocity_comparison_by_type.png\")) \ud83d\udcc8 Additional Visualizations \ud83e\ude90 Individual Cosmic Velocities Earth Moon Mars Jupiter \ud83d\udcca Comparison by Velocity Type \u2705 Conclusion Understanding the derivation and values of cosmic velocities is essential in mission planning, fuel calculations, and interplanetary or interstellar travel. The gravitational properties of different celestial bodies dramatically affect how much energy is required for escape and beyond. \ud83d\udcc2 Deliverables This Markdown document Embedded Python script Graphs and tables for visual comparison visit my colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-derivations-calculations-comparisons","text":"","title":"\ud83d\ude80 Cosmic Velocities: Derivations, Calculations &amp; Comparisons"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"To stay in a circular orbit, the gravitational force must equal centripetal force: v\u2081 = \u221a(GM / r) Where: - G : Universal gravitational constant - M : Mass of the planet - r : Distance from the planet's center (or surface radius)","title":"1\ufe0f\u20e3 First Cosmic Velocity \u2014 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"To escape a planet's gravity, an object must have enough kinetic energy to equal the gravitational potential energy: v\u2082 = \u221a(2GM / r) = \u221a2 \u00d7 v\u2081","title":"2\ufe0f\u20e3 Second Cosmic Velocity \u2014 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-leaving-the-star-system","text":"To leave the solar system, an object must escape not only the planet\u2019s gravity, but also the Sun\u2019s gravity from the planet\u2019s orbital position: v\u2083 = \u221a(v_sun_escape\u00b2 + v_orbit\u00b2) Where: - v_sun_escape = \u221a(2GM_sun / r_orbit) - v_orbit = orbital speed of the planet around the Sun","title":"3\ufe0f\u20e3 Third Cosmic Velocity \u2014 Leaving the Star System"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth-numerical-values","text":"Using Earth mass and radius: \\( M = 5.972 \\times 10^{24} \\) kg \\( r = 6.371 \\times 10^6 \\) m \\( G = 6.67430 \\times 10^{-11} \\) We find: First velocity (orbit) : ~7900 m/s Second velocity (escape) : ~11200 m/s Third velocity (leave solar system) : ~42100 m/s","title":"\ud83c\udf0d Earth: Numerical Values"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-table-earth-vs-moon-mars-jupiter","text":"Body v\u2081 (orbit) v\u2082 (escape) v\u2083 (solar escape) Earth ~7900 m/s ~11200 m/s ~42100 m/s Moon ~1700 m/s ~2400 m/s ~41000 m/s Mars ~3500 m/s ~5000 m/s ~36500 m/s Jupiter ~42000 m/s ~59500 m/s ~61700 m/s","title":"\ud83d\udcca Comparison Table: Earth vs Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-to-generate-visualizations-for-colab","text":"import numpy as np import matplotlib.pyplot as plt from IPython.display import Image, display # Gravitational constant G = 6.67430e-11 # Celestial body data: [mass (kg), radius (m), orbital speed around Sun (m/s)] bodies = { \"Earth\": [5.972e24, 6.371e6, 29.78e3], \"Moon\": [7.347e22, 1.737e6, 1.022e3], \"Mars\": [6.417e23, 3.3895e6, 24.077e3], \"Jupiter\": [1.898e27, 6.9911e7, 13.07e3] } M_sun = 1.989e30 AU = 1.496e11 # Calculate cosmic velocities results = {} for name, (mass, radius, v_orb) in bodies.items(): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_sun_escape = np.sqrt(2 * G * M_sun / AU) v3 = np.sqrt(v_sun_escape**2 + v_orb**2) results[name] = [v1, v2, v3] labels = [\"v\u2081 (Orbit)\", \"v\u2082 (Escape)\", \"v\u2083 (Solar Escape)\"] # Individual bar charts per planet for name, velocities in results.items(): plt.figure() plt.bar(labels, velocities) plt.title(f\"{name} - Cosmic Velocities\") plt.ylabel(\"Velocity (m/s)\") plt.grid(True) plt.tight_layout() filename = f\"{name.lower()}_velocities.png\" plt.savefig(filename) display(Image(filename)) plt.close() # Comparison chart: velocity types across planets v1_vals, v2_vals, v3_vals = [], [], [] planet_names = list(results.keys()) for name in planet_names: v1_vals.append(results[name][0]) v2_vals.append(results[name][1]) v3_vals.append(results[name][2]) x = np.arange(len(planet_names)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_vals, width, label=\"v\u2081 (Orbit)\") ax.bar(x, v2_vals, width, label=\"v\u2082 (Escape)\") ax.bar(x + width, v3_vals, width, label=\"v\u2083 (Solar Escape)\") ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Comparison of Cosmic Velocities Across Celestial Bodies\") ax.set_xticks(x) ax.set_xticklabels(planet_names) ax.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"velocity_comparison_by_type.png\") display(Image(\"velocity_comparison_by_type.png\"))","title":"\ud83e\udde0 Python Code to Generate Visualizations (For Colab)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#additional-visualizations","text":"","title":"\ud83d\udcc8 Additional Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#individual-cosmic-velocities","text":"","title":"\ud83e\ude90 Individual Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#moon","text":"","title":"Moon"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-by-velocity-type","text":"","title":"\ud83d\udcca Comparison by Velocity Type"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding the derivation and values of cosmic velocities is essential in mission planning, fuel calculations, and interplanetary or interstellar travel. The gravitational properties of different celestial bodies dramatically affect how much energy is required for escape and beyond.","title":"\u2705 Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"This Markdown document Embedded Python script Graphs and tables for visual comparison visit my colab","title":"\ud83d\udcc2 Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic , hyperbolic , elliptical ) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Hints and Resources Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws , to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning , satellite deployment , and planetary exploration . These tasks provide a foundation for understanding gravity's influence on motion and its role in celestial mechanics and space exploration . Simulation Code The following Python code simulates the motion of a payload released 800 km above Earth with varying initial speeds. The simulation tracks the position of the payload over time under the influence of Earth's gravity, and plots the resulting trajectories. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude # Simulation parameters dt = 2 t_max = 30000 # Initial position r0 = np.array([initial_radius, 0]) # Initial velocities velocities_kms = np.arange(5, 13.5, 1.0) velocities = velocities_kms * 1000 def gravity_acc(r): return -G * M_earth * r / np.linalg.norm(r)**3 fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, facecolor='blue', edgecolor='black', alpha=0.5, label='Earth') ax.add_artist(earth) ax.scatter(0, 0, color='black', s=20, label='Center of Earth') for v0 in velocities: r = r0.copy() v = np.array([0.0, v0]) xs, ys = [], [] for _ in range(t_max): a = gravity_acc(r) v += a * dt r += v * dt xs.append(r[0]) ys.append(r[1]) if np.linalg.norm(r) <= R_earth: break ax.plot(xs, ys, label=f'{v0/1000:.1f} km/s') ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories in a Gravitational Field with Filled Earth') ax.legend(title=\"Initial Speed\", loc='center left', bbox_to_anchor=(1, 0.5)) plt.grid(True) plt.tight_layout() plt.savefig(\"trajectory_plot_updated.png\") plt.show() Results and Visualizations Simulated Payload Trajectories Distance from Earth vs Time (for Selected Velocities) Code for Distance vs Time Plot import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) selected_velocities = [6000, 10900, 12000] labels = [\"6 km/s\", \"10.9 km/s\", \"12 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(selected_velocities, labels): r = np.array([initial_radius, 0.0]) v = np.array([0.0, v0]) rs, times = [], [] for step in range(steps): a = -G * M_earth * r / np.linalg.norm(r)**3 v += a * dt r += v * dt rs.append(np.linalg.norm(r)) times.append(step * dt) if np.linalg.norm(r) <= R_earth: break plt.plot(times, rs, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Distance from Earth's center (m)\") plt.title(\"Distance from Earth vs Time\") plt.axhline(R_earth, color='black', linestyle='--', label=\"Earth Surface\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"distance_vs_time.png\") plt.show() Speed vs Time (for Selected Velocities) Code for Speed vs Time Plot import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) selected_velocities = [6000, 10900, 12000] labels = [\"6 km/s\", \"10.9 km/s\", \"12 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(selected_velocities, labels): r = np.array([initial_radius, 0.0]) v = np.array([0.0, v0]) speeds, times = [], [] for step in range(steps): a = -G * M_earth * r / np.linalg.norm(r)**3 v += a * dt r += v * dt speeds.append(np.linalg.norm(v)) times.append(step * dt) if np.linalg.norm(r) <= R_earth: break plt.plot(times, speeds, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Speed (m/s)\") plt.title(\"Speed vs Time\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"speed_vs_time.png\") plt.show() Altitude vs Time (for Selected Velocities) Code for Altitude vs Time Plot import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 R = 6371e3 altitude = 800e3 r0_mag = R + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) velocities = [5000, 7000, 10000, 13000] labels = [\"5.0 km/s\", \"7.0 km/s\", \"10.0 km/s\", \"13.0 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(velocities, labels): r = np.array([r0_mag, 0.0]) v = np.array([0.0, v0]) altitudes, times = [], [] for step in range(steps): a = -G * M * r / np.linalg.norm(r)**3 v += a * dt r += v * dt h = np.linalg.norm(r) - R altitudes.append(h) times.append(step * dt) if np.linalg.norm(r) <= R: break plt.plot(times, altitudes, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude (m)\") plt.title(\"Altitude vs Time for Different Initial Velocities\") plt.axhline(0, color='black', linestyle='--', label=\"Earth Surface\") plt.legend(title=\"Initial Speed\", loc=\"center left\", bbox_to_anchor=(1, 0.5)) plt.grid(True) plt.tight_layout() plt.savefig(\"altitude_vs_time.png\") plt.show() Escape Velocity at 800 km Altitude The theoretical escape velocity at 800 km above Earth's surface is: \\[ v_{escape} = \\sqrt{ \\frac{2GM}{R + h} } \\approx 10.9 \\, \\text{km/s} \\] This is the minimum speed required for an object to escape Earth's gravitational pull without further propulsion. As seen in the plot, trajectories with speeds above this threshold result in escape paths. Observed Trajectories Summary Initial Velocity (km/s) Expected Path Type 5.0 \u2013 10.5 Elliptical / returns \u2248 10.9 Parabolic (escape) > 11.0 Hyperbolic (escape) Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of orbital trajectories, escape velocities, and payload trajectories near Earth. visit my colab","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic , hyperbolic , elliptical ) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#hints-and-resources","text":"Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws , to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning , satellite deployment , and planetary exploration . These tasks provide a foundation for understanding gravity's influence on motion and its role in celestial mechanics and space exploration .","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-code","text":"The following Python code simulates the motion of a payload released 800 km above Earth with varying initial speeds. The simulation tracks the position of the payload over time under the influence of Earth's gravity, and plots the resulting trajectories. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude # Simulation parameters dt = 2 t_max = 30000 # Initial position r0 = np.array([initial_radius, 0]) # Initial velocities velocities_kms = np.arange(5, 13.5, 1.0) velocities = velocities_kms * 1000 def gravity_acc(r): return -G * M_earth * r / np.linalg.norm(r)**3 fig, ax = plt.subplots(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, facecolor='blue', edgecolor='black', alpha=0.5, label='Earth') ax.add_artist(earth) ax.scatter(0, 0, color='black', s=20, label='Center of Earth') for v0 in velocities: r = r0.copy() v = np.array([0.0, v0]) xs, ys = [], [] for _ in range(t_max): a = gravity_acc(r) v += a * dt r += v * dt xs.append(r[0]) ys.append(r[1]) if np.linalg.norm(r) <= R_earth: break ax.plot(xs, ys, label=f'{v0/1000:.1f} km/s') ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Trajectories in a Gravitational Field with Filled Earth') ax.legend(title=\"Initial Speed\", loc='center left', bbox_to_anchor=(1, 0.5)) plt.grid(True) plt.tight_layout() plt.savefig(\"trajectory_plot_updated.png\") plt.show()","title":"Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#results-and-visualizations","text":"","title":"Results and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulated-payload-trajectories","text":"","title":"Simulated Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#distance-from-earth-vs-time-for-selected-velocities","text":"","title":"Distance from Earth vs Time (for Selected Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code-for-distance-vs-time-plot","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) selected_velocities = [6000, 10900, 12000] labels = [\"6 km/s\", \"10.9 km/s\", \"12 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(selected_velocities, labels): r = np.array([initial_radius, 0.0]) v = np.array([0.0, v0]) rs, times = [], [] for step in range(steps): a = -G * M_earth * r / np.linalg.norm(r)**3 v += a * dt r += v * dt rs.append(np.linalg.norm(r)) times.append(step * dt) if np.linalg.norm(r) <= R_earth: break plt.plot(times, rs, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Distance from Earth's center (m)\") plt.title(\"Distance from Earth vs Time\") plt.axhline(R_earth, color='black', linestyle='--', label=\"Earth Surface\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"distance_vs_time.png\") plt.show()","title":"Code for Distance vs Time Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#speed-vs-time-for-selected-velocities","text":"","title":"Speed vs Time (for Selected Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code-for-speed-vs-time-plot","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371e3 altitude = 800e3 initial_radius = R_earth + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) selected_velocities = [6000, 10900, 12000] labels = [\"6 km/s\", \"10.9 km/s\", \"12 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(selected_velocities, labels): r = np.array([initial_radius, 0.0]) v = np.array([0.0, v0]) speeds, times = [], [] for step in range(steps): a = -G * M_earth * r / np.linalg.norm(r)**3 v += a * dt r += v * dt speeds.append(np.linalg.norm(v)) times.append(step * dt) if np.linalg.norm(r) <= R_earth: break plt.plot(times, speeds, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Speed (m/s)\") plt.title(\"Speed vs Time\") plt.legend() plt.grid(True) plt.tight_layout() plt.savefig(\"speed_vs_time.png\") plt.show()","title":"Code for Speed vs Time Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#altitude-vs-time-for-selected-velocities","text":"","title":"Altitude vs Time (for Selected Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code-for-altitude-vs-time-plot","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 M = 5.972e24 R = 6371e3 altitude = 800e3 r0_mag = R + altitude dt = 2 t_max = 30000 steps = int(t_max / dt) velocities = [5000, 7000, 10000, 13000] labels = [\"5.0 km/s\", \"7.0 km/s\", \"10.0 km/s\", \"13.0 km/s\"] plt.figure(figsize=(10, 6)) for v0, label in zip(velocities, labels): r = np.array([r0_mag, 0.0]) v = np.array([0.0, v0]) altitudes, times = [], [] for step in range(steps): a = -G * M * r / np.linalg.norm(r)**3 v += a * dt r += v * dt h = np.linalg.norm(r) - R altitudes.append(h) times.append(step * dt) if np.linalg.norm(r) <= R: break plt.plot(times, altitudes, label=label) plt.xlabel(\"Time (s)\") plt.ylabel(\"Altitude (m)\") plt.title(\"Altitude vs Time for Different Initial Velocities\") plt.axhline(0, color='black', linestyle='--', label=\"Earth Surface\") plt.legend(title=\"Initial Speed\", loc=\"center left\", bbox_to_anchor=(1, 0.5)) plt.grid(True) plt.tight_layout() plt.savefig(\"altitude_vs_time.png\") plt.show()","title":"Code for Altitude vs Time Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity-at-800-km-altitude","text":"The theoretical escape velocity at 800 km above Earth's surface is: \\[ v_{escape} = \\sqrt{ \\frac{2GM}{R + h} } \\approx 10.9 \\, \\text{km/s} \\] This is the minimum speed required for an object to escape Earth's gravitational pull without further propulsion. As seen in the plot, trajectories with speeds above this threshold result in escape paths.","title":"Escape Velocity at 800 km Altitude"},{"location":"1%20Physics/2%20Gravity/Problem_3/#observed-trajectories-summary","text":"Initial Velocity (km/s) Expected Path Type 5.0 \u2013 10.5 Elliptical / returns \u2248 10.9 Parabolic (escape) > 11.0 Hyperbolic (escape)","title":"Observed Trajectories Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of orbital trajectories, escape velocities, and payload trajectories near Earth. visit my colab","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Task A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) \u2014 displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\(A\\) \u2014 amplitude of the wave \\(k = \\dfrac{2\\pi}{\\lambda}\\) \u2014 wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) \u2014 angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) \u2014 distance from the source to point \\((x, y)\\) \\(\\phi\\) \u2014 initial phase Problem Statement Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. Steps to Follow Select a Regular Polygon : Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources : Place point wave sources at the vertices of the selected polygon. Wave Equations : Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves : Apply the principle of superposition by summing the wave displacements at each point on the water surface: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where: \\(N\\) \u2014 the number of sources (i.e., the number of vertices of the polygon) The following code simulates the wave propagation from a single point source on a 2D water surface. Both a heatmap and 3D surface plot are used to visualize the wave pattern. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create the spatial grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Wave parameters A = 1 # Amplitude wavelength = 2 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi = 0 # Initial phase t = 0 # Time snapshot # Position of the single point source x0, y0 = (0, 0) # Distance from each grid point to the source r = np.sqrt((X - x0)**2 + (Y - y0)**2) # Wave function without amplitude attenuation eta = np.cos(k * r - omega * t + phi) # --- HEATMAP --- plt.figure(figsize=(6, 6)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='RdBu') plt.colorbar(label='Amplitude') plt.clim(-1, 1) plt.axis('equal') plt.title(\"Wave Heatmap - Single Source\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.tight_layout() plt.savefig(\"heatmap_single.png\") plt.show() # --- 3D PLOT --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta, cmap='RdBu', linewidth=0, antialiased=True) ax.set_title(\"3D Wave Plot - Single Source\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Amplitude\") ax.set_zlim(-1.2, 1.2) plt.tight_layout() plt.savefig(\"wave3d_single.png\") plt.show() Simulation: Heatmap from a Single Point Source This heatmap shows the amplitude distribution of the wave from a single point source over a 2D grid. Simulation: 3D Wave Surface from a Single Point Source Simulation: Heatmap from Two Point Sources The following Python code simulates the wave interference caused by two identical point sources. The resulting interference pattern is visualized as both a heatmap and a 3D surface plot. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Parameters wavelength = 2 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0 # Two sources source1 = (-3, 0) source2 = (3, 0) # Distance from each source r1 = np.sqrt((X - source1[0])**2 + (Y - source1[1])**2) r2 = np.sqrt((X - source2[0])**2 + (Y - source2[1])**2) # Interference pattern (no amplitude attenuation) eta = np.cos(k * r1 - omega * t + phi) + np.cos(k * r2 - omega * t + phi) eta /= 2 # --- HEATMAP --- plt.figure(figsize=(6, 6)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='RdBu') plt.colorbar(label='Amplitude') plt.clim(-1, 1) plt.axis('equal') plt.title(\"Interference Heatmap - Two Sources\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.tight_layout() plt.savefig(\"interference_two_sources.png\") plt.show() # --- 3D PLOT --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta, cmap='RdBu', linewidth=0, antialiased=True) ax.set_title(\"3D Interference Plot - Two Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Amplitude\") ax.set_zlim(-1.2, 1.2) plt.tight_layout() plt.savefig(\"interference3d_two_sources.png\") plt.show() Interference Pattern - Two Sources This figure shows a clear interference pattern generated by two sources placed symmetrically along the x-axis. Simulation: 3D Interference Surface from Two Point Sources A 3D surface plot of the interference wave pattern created by two point sources placed symmetrically on the x-axis. \ud83c\udf0a Wave Interference Visualization This project simulates and visualizes 2D wave interference using multiple point sources. \ud83c\udfaf Objective Visualize wave interference for: - 1 source - 2 sources - 3 sources in triangle layout - 5 sources in pentagon layout Both 2D heatmaps and a 3D animation are included. \ud83d\udcc8 GIF Animations \ud83d\udd35 One Source (GIF) \ud83d\udd35 Two Sources (GIF) \ud83d\udd3a Triangle Sources (GIF) \u2b1f Pentagon (3D View) (GIF) Considerations Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining a constant phase difference. You may use simulation and visualization tools such as Python (with libraries like Matplotlib), or other graphical software to aid in your analysis. Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the interference patterns observed for the chosen regular polygon with the goal of understanding wave superposition. Graphical representations of the water surface showing constructive and destructive interference regions. \ud83e\udde9 Conclusion The simulations clearly demonstrate how wave interference patterns depend on the number and arrangement of sources. Two sources produce the classic constructive and destructive bands, while triangle and pentagon layouts create more complex and symmetric patterns. This highlights how the principle of superposition leads to rich and predictable wave behaviors in 2D media. visit my colab","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"A circular wave on the water surface, emanating from a point source located at \\((x_0, y_0)\\) , can be described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) \u2014 displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\(A\\) \u2014 amplitude of the wave \\(k = \\dfrac{2\\pi}{\\lambda}\\) \u2014 wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) \u2014 angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) \u2014 distance from the source to point \\((x, y)\\) \\(\\phi\\) \u2014 initial phase","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon : Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources : Place point wave sources at the vertices of the selected polygon. Wave Equations : Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves : Apply the principle of superposition by summing the wave displacements at each point on the water surface: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where: \\(N\\) \u2014 the number of sources (i.e., the number of vertices of the polygon) The following code simulates the wave propagation from a single point source on a 2D water surface. Both a heatmap and 3D surface plot are used to visualize the wave pattern. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create the spatial grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Wave parameters A = 1 # Amplitude wavelength = 2 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi = 0 # Initial phase t = 0 # Time snapshot # Position of the single point source x0, y0 = (0, 0) # Distance from each grid point to the source r = np.sqrt((X - x0)**2 + (Y - y0)**2) # Wave function without amplitude attenuation eta = np.cos(k * r - omega * t + phi) # --- HEATMAP --- plt.figure(figsize=(6, 6)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='RdBu') plt.colorbar(label='Amplitude') plt.clim(-1, 1) plt.axis('equal') plt.title(\"Wave Heatmap - Single Source\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.tight_layout() plt.savefig(\"heatmap_single.png\") plt.show() # --- 3D PLOT --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta, cmap='RdBu', linewidth=0, antialiased=True) ax.set_title(\"3D Wave Plot - Single Source\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Amplitude\") ax.set_zlim(-1.2, 1.2) plt.tight_layout() plt.savefig(\"wave3d_single.png\") plt.show()","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-heatmap-from-a-single-point-source","text":"This heatmap shows the amplitude distribution of the wave from a single point source over a 2D grid.","title":"Simulation: Heatmap from a Single Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-3d-wave-surface-from-a-single-point-source","text":"","title":"Simulation: 3D Wave Surface from a Single Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-heatmap-from-two-point-sources","text":"The following Python code simulates the wave interference caused by two identical point sources. The resulting interference pattern is visualized as both a heatmap and a 3D surface plot. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Parameters wavelength = 2 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0 # Two sources source1 = (-3, 0) source2 = (3, 0) # Distance from each source r1 = np.sqrt((X - source1[0])**2 + (Y - source1[1])**2) r2 = np.sqrt((X - source2[0])**2 + (Y - source2[1])**2) # Interference pattern (no amplitude attenuation) eta = np.cos(k * r1 - omega * t + phi) + np.cos(k * r2 - omega * t + phi) eta /= 2 # --- HEATMAP --- plt.figure(figsize=(6, 6)) plt.pcolormesh(X, Y, eta, shading='auto', cmap='RdBu') plt.colorbar(label='Amplitude') plt.clim(-1, 1) plt.axis('equal') plt.title(\"Interference Heatmap - Two Sources\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.tight_layout() plt.savefig(\"interference_two_sources.png\") plt.show() # --- 3D PLOT --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta, cmap='RdBu', linewidth=0, antialiased=True) ax.set_title(\"3D Interference Plot - Two Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"Amplitude\") ax.set_zlim(-1.2, 1.2) plt.tight_layout() plt.savefig(\"interference3d_two_sources.png\") plt.show()","title":"Simulation: Heatmap from Two Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-pattern-two-sources","text":"This figure shows a clear interference pattern generated by two sources placed symmetrically along the x-axis.","title":"Interference Pattern - Two Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-3d-interference-surface-from-two-point-sources","text":"A 3D surface plot of the interference wave pattern created by two point sources placed symmetrically on the x-axis.","title":"Simulation: 3D Interference Surface from Two Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-visualization","text":"This project simulates and visualizes 2D wave interference using multiple point sources.","title":"\ud83c\udf0a Wave Interference Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#objective","text":"Visualize wave interference for: - 1 source - 2 sources - 3 sources in triangle layout - 5 sources in pentagon layout Both 2D heatmaps and a 3D animation are included.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/3%20Waves/Problem_1/#gif-animations","text":"","title":"\ud83d\udcc8 GIF Animations"},{"location":"1%20Physics/3%20Waves/Problem_1/#one-source-gif","text":"","title":"\ud83d\udd35 One Source (GIF)"},{"location":"1%20Physics/3%20Waves/Problem_1/#two-sources-gif","text":"","title":"\ud83d\udd35 Two Sources (GIF)"},{"location":"1%20Physics/3%20Waves/Problem_1/#triangle-sources-gif","text":"","title":"\ud83d\udd3a Triangle Sources (GIF)"},{"location":"1%20Physics/3%20Waves/Problem_1/#pentagon-3d-view-gif","text":"","title":"\u2b1f Pentagon (3D View) (GIF)"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, maintaining a constant phase difference. You may use simulation and visualization tools such as Python (with libraries like Matplotlib), or other graphical software to aid in your analysis.","title":"Considerations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the interference patterns observed for the chosen regular polygon with the goal of understanding wave superposition. Graphical representations of the water surface showing constructive and destructive interference regions.","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"The simulations clearly demonstrate how wave interference patterns depend on the number and arrangement of sources. Two sources produce the classic constructive and destructive bands, while triangle and pentagon layouts create more complex and symmetric patterns. This highlights how the principle of superposition leads to rich and predictable wave behaviors in 2D media. visit my colab","title":"\ud83e\udde9 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1: Simulating the Effects of the Lorentz Force Motivation The Lorentz force, expressed as F = qE + qv \u00d7 B , governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. Through simulations, we can explore its practical applications and visualize complex particle trajectories. Task Overview Explore Applications Particle accelerators Mass spectrometers Plasma confinement Magnetic traps Simulate Particle Motion Under a uniform magnetic field Under combined electric and magnetic fields Under crossed electric and magnetic fields Parameter Exploration Electric and magnetic field strengths Initial velocity Charge and mass Visualize Circle Spiral in z-direction Drift motion Include labeled 2D/3D plots Lorentz Force Simulation: Circular Motion Introduction This simulation models the motion of a charged particle in a uniform magnetic field with no electric field . The force is: F = q (v \u00d7 B) This results in circular motion in the x-y plane. Parameters Charge (q): 1 C Mass (m): 0.001 kg (1 gram) Magnetic Field (B): [0, 0, 1] T Initial Velocity: [1, 0, 0] m/s Output The following image shows the particle\u2019s circular motion: Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Circular Motion in Uniform Magnetic Field') ax.legend(); plt.tight_layout() plt.savefig(\"circular_motion.png\", dpi=300) plt.show() Lorentz Force Simulation: Helical (Spiral) Motion Introduction By adding a z-component to the initial velocity, the particle now spirals forward, creating helical motion . Parameters Charge (q): 1 C Mass (m): 0.001 kg Magnetic Field (B): [0, 0, 1] T Initial Velocity: [1, 0, 0.5] m/s Output The following image shows the particle\u2019s helical (spiral) motion : Code q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.5]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Helical trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Spiral Motion in Uniform Magnetic Field') ax.legend(); plt.tight_layout() plt.savefig(\"spiral_motion.png\", dpi=300) plt.show() Lorentz Force Simulation: Drift Motion (E \u00d7 B) Introduction When a perpendicular electric field is introduced, the particle undergoes circular motion with a net drift in a fixed direction. This is known as E \u00d7 B drift . Parameters Electric Field (E): [1, 0, 0] V/m Magnetic Field (B): [0, 0, 1] T Charge (q): 1 C Mass (m): 0.001 kg Initial Velocity: [0, 1, 0] m/s Expected Drift: [0, 1, 0] m/s Output The following image shows the particle\u2019s drift motion caused by crossed E and B fields: Code q = 1.0 m = 0.001 E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.0, 1.0, 0.0]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Drift trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Drift Motion in E \u00d7 B Fields') ax.legend(); plt.tight_layout() plt.savefig(\"drift_motion.png\", dpi=300) plt.show() Summary & Notes The circular and helical motions are caused by the magnetic field acting on the charged particle. The E \u00d7 B drift results from crossed electric and magnetic fields. All simulations use the Euler method . You can extend these simulations to: Non-uniform fields Multiple particles Relativistic speeds \ud83d\udce6 Deliverables A Markdown report documenting the physics background and simulation results for the Lorentz force. Embedded Python scripts modeling: Circular motion Helical motion E \u00d7 B drift motion Graphical outputs ( .png files) showing particle trajectories under different field configurations: circular_motion.png spiral_motion.png drift_motion.png Interpretation of results based on field strength, direction, and particle velocity. \ud83e\udde9 Conclusion The Lorentz force simulations successfully visualize how charged particles move in response to magnetic and electric fields. We observed three key behaviors: Circular motion under a uniform magnetic field Helical motion when the initial velocity has a component along the field E \u00d7 B drift in the presence of perpendicular electric and magnetic fields These results align with electromagnetic theory and offer insight into the design of devices like cyclotrons , mass spectrometers , and plasma confinement systems . Overall, the simulations deepen our understanding of particle dynamics and demonstrate how classical physics principles translate into motion. visit my colab","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as F = qE + qv \u00d7 B , governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. Through simulations, we can explore its practical applications and visualize complex particle trajectories.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-overview","text":"Explore Applications Particle accelerators Mass spectrometers Plasma confinement Magnetic traps Simulate Particle Motion Under a uniform magnetic field Under combined electric and magnetic fields Under crossed electric and magnetic fields Parameter Exploration Electric and magnetic field strengths Initial velocity Charge and mass Visualize Circle Spiral in z-direction Drift motion Include labeled 2D/3D plots","title":"Task Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-circular-motion","text":"","title":"Lorentz Force Simulation: Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"This simulation models the motion of a charged particle in a uniform magnetic field with no electric field . The force is: F = q (v \u00d7 B) This results in circular motion in the x-y plane.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Charge (q): 1 C Mass (m): 0.001 kg (1 gram) Magnetic Field (B): [0, 0, 1] T Initial Velocity: [1, 0, 0] m/s","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#output","text":"The following image shows the particle\u2019s circular motion:","title":"Output"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.0]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Circular Motion in Uniform Magnetic Field') ax.legend(); plt.tight_layout() plt.savefig(\"circular_motion.png\", dpi=300) plt.show()","title":"Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-helical-spiral-motion","text":"","title":"Lorentz Force Simulation: Helical (Spiral) Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction_1","text":"By adding a z-component to the initial velocity, the particle now spirals forward, creating helical motion .","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters_1","text":"Charge (q): 1 C Mass (m): 0.001 kg Magnetic Field (B): [0, 0, 1] T Initial Velocity: [1, 0, 0.5] m/s","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#output_1","text":"The following image shows the particle\u2019s helical (spiral) motion :","title":"Output"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code_1","text":"q = 1.0 m = 0.001 B = np.array([0, 0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 0.0, 0.5]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * np.cross(v[i], B) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Helical trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Spiral Motion in Uniform Magnetic Field') ax.legend(); plt.tight_layout() plt.savefig(\"spiral_motion.png\", dpi=300) plt.show()","title":"Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-drift-motion-e-b","text":"","title":"Lorentz Force Simulation: Drift Motion (E \u00d7 B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction_2","text":"When a perpendicular electric field is introduced, the particle undergoes circular motion with a net drift in a fixed direction. This is known as E \u00d7 B drift .","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters_2","text":"Electric Field (E): [1, 0, 0] V/m Magnetic Field (B): [0, 0, 1] T Charge (q): 1 C Mass (m): 0.001 kg Initial Velocity: [0, 1, 0] m/s Expected Drift: [0, 1, 0] m/s","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#output_2","text":"The following image shows the particle\u2019s drift motion caused by crossed E and B fields:","title":"Output"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code_2","text":"q = 1.0 m = 0.001 E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([0.0, 1.0, 0.0]) dt = 0.001 T = 10 N = int(T / dt) r = np.zeros((N, 3)) v = np.zeros((N, 3)) t = np.linspace(0, T, N) r[0], v[0] = r0, v0 for i in range(N - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Drift trajectory') ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z') ax.set_title('Drift Motion in E \u00d7 B Fields') ax.legend(); plt.tight_layout() plt.savefig(\"drift_motion.png\", dpi=300) plt.show()","title":"Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#summary-notes","text":"The circular and helical motions are caused by the magnetic field acting on the charged particle. The E \u00d7 B drift results from crossed electric and magnetic fields. All simulations use the Euler method . You can extend these simulations to: Non-uniform fields Multiple particles Relativistic speeds","title":"Summary &amp; Notes"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"A Markdown report documenting the physics background and simulation results for the Lorentz force. Embedded Python scripts modeling: Circular motion Helical motion E \u00d7 B drift motion Graphical outputs ( .png files) showing particle trajectories under different field configurations: circular_motion.png spiral_motion.png drift_motion.png Interpretation of results based on field strength, direction, and particle velocity.","title":"\ud83d\udce6 Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"The Lorentz force simulations successfully visualize how charged particles move in response to magnetic and electric fields. We observed three key behaviors: Circular motion under a uniform magnetic field Helical motion when the initial velocity has a component along the field E \u00d7 B drift in the presence of perpendicular electric and magnetic fields These results align with electromagnetic theory and offer insight into the design of devices like cyclotrons , mass spectrometers , and plasma confinement systems . Overall, the simulations deepen our understanding of particle dynamics and demonstrate how classical physics principles translate into motion. visit my colab","title":"\ud83e\udde9 Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory \ud83d\udd0d Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve applying series and parallel resistor rules, graph theory offers a systematic and scalable alternative. By modeling a circuit as a graph , where: - Nodes represent junctions - Edges represent resistors (with weights = resistance) we can simplify the network using automation. \ud83c\udfaf Task This script: - Accepts a circuit as a graph - Detects and reduces series connections - Detects and reduces parallel connections - Outputs the final equivalent resistance \ud83e\uddea Example Circuit Circuit layout: B+ \u2014 R1 \u2014 R2 \u2014 R3 \u2014 R4 \u2014 R5 \u2014 B- Each resistor has: - R1 = 2 \u03a9 - R2 = 3 \u03a9 - R3 = 6 \u03a9 - R4 = 2 \u03a9 - R5 = 3 \u03a9 # STEP 1: Install NetworkX (only needed once in Colab) !pip install networkx # STEP 2: Import libraries import networkx as nx import matplotlib.pyplot as plt # === ORIGINAL CIRCUIT === original = nx.MultiGraph() original.add_edge(\"B+\", \"1\", resistance=2) original.add_edge(\"1\", \"2\", resistance=3) original.add_edge(\"2\", \"3\", resistance=6) original.add_edge(\"3\", \"4\", resistance=2) original.add_edge(\"4\", \"B-\", resistance=3) # Draw original circuit pos1 = nx.spring_layout(original, seed=42) plt.figure(figsize=(7, 5)) nx.draw(original, pos1, with_labels=True, node_color='lightgreen', node_size=2000, font_size=14) labels1 = nx.get_edge_attributes(original, 'resistance') nx.draw_networkx_edge_labels(original, pos1, edge_labels=labels1, font_color='black') plt.title(\"Original Circuit: B+ to B- with R1 to R5\") plt.tight_layout() plt.savefig(\"original_circuit.png\", dpi=300) plt.show() # === COPY original to a new graph to simplify === G = original.copy() # Simplify series connections def simplify_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree[node] == 2 and node not in [\"B+\", \"B-\"]: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[u][node][0]['resistance'] R2 = G[node][v][0]['resistance'] G.remove_edge(u, node) G.remove_edge(node, v) G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) print(f\"\u2714\ufe0f Combined series: {u}-{node}-{v} \u2192 {u}-{v} with R = {R1 + R2}\") changed = True break # Simplify parallel connections def simplify_parallel(G): for u, v in list(G.edges()): edge_data = list(G.get_edge_data(u, v).items()) if len(edge_data) > 1: R1 = edge_data[0][1]['resistance'] R2 = edge_data[1][1]['resistance'] G.remove_edge(u, v, key=edge_data[0][0]) G.remove_edge(u, v, key=edge_data[1][0]) if R1 + R2 != 0: R_eq = (R1 * R2) / (R1 + R2) G.add_edge(u, v, resistance=R_eq) print(f\"\u26a1 Combined parallel: {u}={v} \u2192 1 edge with R = {R_eq:.2f}\") else: print(f\"\u26a0\ufe0f Cannot reduce {u}-{v}: R1 + R2 = 0\") # Run simplification print(\"\\n\ud83d\udd27 Before simplification:\") print(list(G.edges(data=True))) simplify_series(G) simplify_parallel(G) print(\"\\n\u2705 After simplification:\") print(list(G.edges(data=True))) # Draw simplified circuit pos2 = nx.spring_layout(G, seed=42) plt.figure(figsize=(6, 4)) nx.draw(G, pos2, with_labels=True, node_color='skyblue', node_size=2000, font_size=14, font_weight='bold') labels2 = nx.get_edge_attributes(G, 'resistance') nx.draw_networkx_edge_labels(G, pos2, edge_labels=labels2, font_color='red', font_size=12) plt.title(\"Simplified Circuit: Equivalent Resistance\") plt.tight_layout() plt.savefig(\"simplified_circuit.png\", dpi=300) plt.show() \ud83d\udd27 Original Circuit Output \u2705 Simplified Circuit Output \ud83e\uddea Bonus Test Case: Parallel Resistors This test case demonstrates how the algorithm handles parallel connections between two resistors. Circuit layout: \u250c\u2500\u2500\u2500\u2500 R1 = 4\u03a9 \u2500\u2500\u2500\u2500\u2500\u2510 B+\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 B\u2212 \u2514\u2500\u2500\u2500\u2500 R2 = 6\u03a9 \u2500\u2500\u2500\u2500\u2500\u2518 ``` Expected equivalent resistance: $R_\\text{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\\,\\Omega$ --- ### \ud83d\udd22 Code ```python import networkx as nx import matplotlib.pyplot as plt # Create graph with parallel resistors G_parallel = nx.MultiGraph() G_parallel.add_edge(\"B+\", \"B-\", resistance=4) # R1 G_parallel.add_edge(\"B+\", \"B-\", resistance=6) # R2 # Visualize original parallel circuit pos_p = {\"B+\": (0, 0), \"B-\": (1, 0)} plt.figure(figsize=(5, 3)) nx.draw(G_parallel, pos_p, with_labels=True, node_color='orange', node_size=2000, font_size=14) labels = nx.get_edge_attributes(G_parallel, 'resistance') nx.draw_networkx_edge_labels(G_parallel, pos_p, edge_labels=labels) plt.title(\"Parallel Circuit: R1 = 4\u03a9, R2 = 6\u03a9\") plt.tight_layout() plt.savefig(\"parallel_original.png\", dpi=300) plt.show() # Simplify parallel connection def simplify_parallel(G): for u, v in list(G.edges()): edge_data = list(G.get_edge_data(u, v).items()) if len(edge_data) > 1: R1 = edge_data[0][1]['resistance'] R2 = edge_data[1][1]['resistance'] G.remove_edge(u, v, key=edge_data[0][0]) G.remove_edge(u, v, key=edge_data[1][0]) R_eq = (R1 * R2) / (R1 + R2) G.add_edge(u, v, resistance=R_eq) print(f\"\u26a1 Parallel reduced: {u}\u2013{v} \u2192 R = {R_eq:.2f} \u03a9\") simplify_parallel(G_parallel) # Visualize simplified version plt.figure(figsize=(5, 3)) nx.draw(G_parallel, pos_p, with_labels=True, node_color='cyan', node_size=2000, font_size=14) labels = nx.get_edge_attributes(G_parallel, 'resistance') nx.draw_networkx_edge_labels(G_parallel, pos_p, edge_labels=labels) plt.title(\"Simplified Parallel Circuit\") plt.tight_layout() plt.savefig(\"parallel_simplified.png\", dpi=300) plt.show() \ud83d\uddbc Bonus Circuit Preview \ud83d\udd36 Before: \ud83d\udd37 After: \ud83d\udce6 Deliverables A complete Python implementation of a resistor-simplification algorithm using graph theory Visual diagrams showing: The original circuit as a graph The simplified result after series/parallel reductions Markdown documentation explaining: How the algorithm works An example input and output Two generated output images: original_circuit.png simplified_circuit.png \ud83e\udde9 Conclusion This project demonstrates how graph theory provides an elegant and automated way to compute equivalent resistance in electrical circuits. By modeling resistors as weighted edges in a graph, we can use simple algorithmic logic to reduce both series and parallel combinations. The simulation confirmed that: - The method works for basic and moderately complex circuits - It outputs consistent results with known resistor rules - The process is easily extendable to larger networks Overall, this approach builds a bridge between physics and programming \u2014 and shows how graph structures can simplify circuit analysis. visit my colab","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve applying series and parallel resistor rules, graph theory offers a systematic and scalable alternative. By modeling a circuit as a graph , where: - Nodes represent junctions - Edges represent resistors (with weights = resistance) we can simplify the network using automation.","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task","text":"This script: - Accepts a circuit as a graph - Detects and reduces series connections - Detects and reduces parallel connections - Outputs the final equivalent resistance","title":"\ud83c\udfaf Task"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuit","text":"Circuit layout: B+ \u2014 R1 \u2014 R2 \u2014 R3 \u2014 R4 \u2014 R5 \u2014 B- Each resistor has: - R1 = 2 \u03a9 - R2 = 3 \u03a9 - R3 = 6 \u03a9 - R4 = 2 \u03a9 - R5 = 3 \u03a9 # STEP 1: Install NetworkX (only needed once in Colab) !pip install networkx # STEP 2: Import libraries import networkx as nx import matplotlib.pyplot as plt # === ORIGINAL CIRCUIT === original = nx.MultiGraph() original.add_edge(\"B+\", \"1\", resistance=2) original.add_edge(\"1\", \"2\", resistance=3) original.add_edge(\"2\", \"3\", resistance=6) original.add_edge(\"3\", \"4\", resistance=2) original.add_edge(\"4\", \"B-\", resistance=3) # Draw original circuit pos1 = nx.spring_layout(original, seed=42) plt.figure(figsize=(7, 5)) nx.draw(original, pos1, with_labels=True, node_color='lightgreen', node_size=2000, font_size=14) labels1 = nx.get_edge_attributes(original, 'resistance') nx.draw_networkx_edge_labels(original, pos1, edge_labels=labels1, font_color='black') plt.title(\"Original Circuit: B+ to B- with R1 to R5\") plt.tight_layout() plt.savefig(\"original_circuit.png\", dpi=300) plt.show() # === COPY original to a new graph to simplify === G = original.copy() # Simplify series connections def simplify_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree[node] == 2 and node not in [\"B+\", \"B-\"]: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[u][node][0]['resistance'] R2 = G[node][v][0]['resistance'] G.remove_edge(u, node) G.remove_edge(node, v) G.remove_node(node) G.add_edge(u, v, resistance=R1 + R2) print(f\"\u2714\ufe0f Combined series: {u}-{node}-{v} \u2192 {u}-{v} with R = {R1 + R2}\") changed = True break # Simplify parallel connections def simplify_parallel(G): for u, v in list(G.edges()): edge_data = list(G.get_edge_data(u, v).items()) if len(edge_data) > 1: R1 = edge_data[0][1]['resistance'] R2 = edge_data[1][1]['resistance'] G.remove_edge(u, v, key=edge_data[0][0]) G.remove_edge(u, v, key=edge_data[1][0]) if R1 + R2 != 0: R_eq = (R1 * R2) / (R1 + R2) G.add_edge(u, v, resistance=R_eq) print(f\"\u26a1 Combined parallel: {u}={v} \u2192 1 edge with R = {R_eq:.2f}\") else: print(f\"\u26a0\ufe0f Cannot reduce {u}-{v}: R1 + R2 = 0\") # Run simplification print(\"\\n\ud83d\udd27 Before simplification:\") print(list(G.edges(data=True))) simplify_series(G) simplify_parallel(G) print(\"\\n\u2705 After simplification:\") print(list(G.edges(data=True))) # Draw simplified circuit pos2 = nx.spring_layout(G, seed=42) plt.figure(figsize=(6, 4)) nx.draw(G, pos2, with_labels=True, node_color='skyblue', node_size=2000, font_size=14, font_weight='bold') labels2 = nx.get_edge_attributes(G, 'resistance') nx.draw_networkx_edge_labels(G, pos2, edge_labels=labels2, font_color='red', font_size=12) plt.title(\"Simplified Circuit: Equivalent Resistance\") plt.tight_layout() plt.savefig(\"simplified_circuit.png\", dpi=300) plt.show()","title":"\ud83e\uddea Example Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#original-circuit-output","text":"","title":"\ud83d\udd27 Original Circuit Output"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplified-circuit-output","text":"","title":"\u2705 Simplified Circuit Output"},{"location":"1%20Physics/5%20Circuits/Problem_1/#bonus-test-case-parallel-resistors","text":"This test case demonstrates how the algorithm handles parallel connections between two resistors. Circuit layout: \u250c\u2500\u2500\u2500\u2500 R1 = 4\u03a9 \u2500\u2500\u2500\u2500\u2500\u2510 B+\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 B\u2212 \u2514\u2500\u2500\u2500\u2500 R2 = 6\u03a9 \u2500\u2500\u2500\u2500\u2500\u2518 ``` Expected equivalent resistance: $R_\\text{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\\,\\Omega$ --- ### \ud83d\udd22 Code ```python import networkx as nx import matplotlib.pyplot as plt # Create graph with parallel resistors G_parallel = nx.MultiGraph() G_parallel.add_edge(\"B+\", \"B-\", resistance=4) # R1 G_parallel.add_edge(\"B+\", \"B-\", resistance=6) # R2 # Visualize original parallel circuit pos_p = {\"B+\": (0, 0), \"B-\": (1, 0)} plt.figure(figsize=(5, 3)) nx.draw(G_parallel, pos_p, with_labels=True, node_color='orange', node_size=2000, font_size=14) labels = nx.get_edge_attributes(G_parallel, 'resistance') nx.draw_networkx_edge_labels(G_parallel, pos_p, edge_labels=labels) plt.title(\"Parallel Circuit: R1 = 4\u03a9, R2 = 6\u03a9\") plt.tight_layout() plt.savefig(\"parallel_original.png\", dpi=300) plt.show() # Simplify parallel connection def simplify_parallel(G): for u, v in list(G.edges()): edge_data = list(G.get_edge_data(u, v).items()) if len(edge_data) > 1: R1 = edge_data[0][1]['resistance'] R2 = edge_data[1][1]['resistance'] G.remove_edge(u, v, key=edge_data[0][0]) G.remove_edge(u, v, key=edge_data[1][0]) R_eq = (R1 * R2) / (R1 + R2) G.add_edge(u, v, resistance=R_eq) print(f\"\u26a1 Parallel reduced: {u}\u2013{v} \u2192 R = {R_eq:.2f} \u03a9\") simplify_parallel(G_parallel) # Visualize simplified version plt.figure(figsize=(5, 3)) nx.draw(G_parallel, pos_p, with_labels=True, node_color='cyan', node_size=2000, font_size=14) labels = nx.get_edge_attributes(G_parallel, 'resistance') nx.draw_networkx_edge_labels(G_parallel, pos_p, edge_labels=labels) plt.title(\"Simplified Parallel Circuit\") plt.tight_layout() plt.savefig(\"parallel_simplified.png\", dpi=300) plt.show()","title":"\ud83e\uddea Bonus Test Case: Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#bonus-circuit-preview","text":"","title":"\ud83d\uddbc Bonus Circuit Preview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#before","text":"","title":"\ud83d\udd36 Before:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#after","text":"","title":"\ud83d\udd37 After:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#deliverables","text":"A complete Python implementation of a resistor-simplification algorithm using graph theory Visual diagrams showing: The original circuit as a graph The simplified result after series/parallel reductions Markdown documentation explaining: How the algorithm works An example input and output Two generated output images: original_circuit.png simplified_circuit.png","title":"\ud83d\udce6 Deliverables"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"This project demonstrates how graph theory provides an elegant and automated way to compute equivalent resistance in electrical circuits. By modeling resistors as weighted edges in a graph, we can use simple algorithmic logic to reduce both series and parallel combinations. The simulation confirmed that: - The method works for basic and moderately complex circuits - It outputs consistent results with known resistor rules - The process is easily extendable to larger networks Overall, this approach builds a bridge between physics and programming \u2014 and shows how graph structures can simplify circuit analysis. visit my colab","title":"\ud83e\udde9 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}